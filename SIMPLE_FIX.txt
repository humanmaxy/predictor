========================================
简单修复方案 - 直接替换代码
========================================

问题1: Tkinter文件对话框错误
在您的 improved_file_manager.py 文件第261行附近，找到：

save_path = filedialog.asksaveasfilename(
    initialname=file_name,    # ❌ 错误的参数名
    ...
)

替换为：

save_path = filedialog.asksaveasfilename(
    initialfile=file_name,    # ✅ 正确的参数名
    ...
)

========================================

问题2: UTF-8解码错误
找到解密相关的代码，例如：

# 原来的解密代码（会导致UTF-8错误）
decrypted_data = fernet.decrypt(encrypted_data)
decoded_text = decrypted_data.decode('utf-8')  # ❌ 这里会出错

替换为：

# 修复后的代码（移除解密，直接使用原始数据）
# 如果文件本来就没加密，直接使用
if isinstance(file_data, str):
    # 文本数据
    with open(save_path, 'w', encoding='utf-8') as f:
        f.write(file_data)
elif isinstance(file_data, bytes):
    # 二进制数据
    with open(save_path, 'wb') as f:
        f.write(file_data)
else:
    # 字典格式的数据
    content = file_data.get('content', '')
    if file_data.get('type') == 'binary':
        import base64
        content = base64.b64decode(content)
        with open(save_path, 'wb') as f:
            f.write(content)
    else:
        with open(save_path, 'w', encoding='utf-8') as f:
            f.write(content)

========================================

完整的 download_selected_file 方法替换：

def download_selected_file(self):
    """下载选中的文件 - 修复版本"""
    try:
        selection = self.file_listbox.curselection()
        if not selection:
            messagebox.showwarning("警告", "请先选择一个文件")
            return
            
        selected_item = self.file_listbox.get(selection[0])
        file_name = selected_item.split(' (')[0] if ' (' in selected_item else selected_item.split()[0]
        
        # 修复文件对话框参数
        save_path = filedialog.asksaveasfilename(
            title="保存文件",
            initialfile=file_name,  # 修复：正确的参数名
            defaultextension="",
            filetypes=[("所有文件", "*.*")]
        )
        
        if save_path:
            # 获取文件数据（根据您的实际存储方式调整）
            file_data = self.shared_files.get(file_name) if hasattr(self, 'shared_files') else None
            
            if file_data:
                # 直接保存，无解密
                if isinstance(file_data, dict):
                    content = file_data.get('content', '')
                    if file_data.get('type') == 'binary':
                        import base64
                        content = base64.b64decode(content)
                        with open(save_path, 'wb') as f:
                            f.write(content)
                    else:
                        with open(save_path, 'w', encoding='utf-8') as f:
                            f.write(content)
                elif isinstance(file_data, str):
                    with open(save_path, 'w', encoding='utf-8') as f:
                        f.write(file_data)
                else:
                    with open(save_path, 'wb') as f:
                        f.write(file_data)
                
                messagebox.showinfo("成功", f"文件已保存到: {save_path}")
            else:
                messagebox.showerror("错误", "文件数据不存在")
                
    except Exception as e:
        messagebox.showerror("错误", f"下载文件失败: {str(e)}")

========================================

修复 on_file_double_click 方法：

def on_file_double_click(self, event=None):
    """文件双击处理"""
    try:
        self.download_selected_file()
    except Exception as e:
        messagebox.showerror("错误", f"处理文件双击失败: {str(e)}")

========================================