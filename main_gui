"""
主用户界面
使用Tkinter创建数字货币分析工具的图形界面
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext, filedialog
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pandas as pd
import threading
import os
import json
from datetime import datetime
import logging

# 导入自定义模块
from data_fetcher import CryptoDataFetcher
from technical_indicators import IndicatorAnalyzer
from chart_plotter import ChartPlotter
from ai_predictor import AIPredictor

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CryptoAnalyzerGUI:
    """数字货币分析工具主界面"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("数字货币技术分析与AI预测工具")
        self.root.geometry("1400x900")
        
        # 初始化组件
        self.data_fetcher = CryptoDataFetcher()
        self.indicator_analyzer = IndicatorAnalyzer()
        self.chart_plotter = ChartPlotter()
        self.ai_predictor = None  # 延迟初始化
        
        # 数据存储
        self.current_data = {}
        self.predictions = {}
        
        # 创建界面
        self.create_widgets()
        self.setup_layout()
        
        # 状态变量
        self.is_loading = False
        
        logger.info("GUI初始化完成")
    
    def create_widgets(self):
        """创建界面组件"""
        # 创建主框架
        self.main_frame = ttk.Frame(self.root)
        
        # 左侧控制面板
        self.control_frame = ttk.LabelFrame(self.main_frame, text="控制面板", padding="10")
        
        # 币种选择
        ttk.Label(self.control_frame, text="选择数字货币:").grid(row=0, column=0, sticky="w", pady=2)
        self.symbol_var = tk.StringVar(value="BTC")
        self.symbol_combo = ttk.Combobox(self.control_frame, textvariable=self.symbol_var, 
                                        values=self.data_fetcher.get_supported_coins(),
                                        state="readonly", width=15)
        self.symbol_combo.grid(row=0, column=1, pady=2, padx=(5, 0))
        
        # 时间范围选择
        ttk.Label(self.control_frame, text="时间范围:").grid(row=1, column=0, sticky="w", pady=2)
        self.days_var = tk.StringVar(value="30")
        self.days_combo = ttk.Combobox(self.control_frame, textvariable=self.days_var,
                                      values=["7", "30", "90", "180", "365"],
                                      state="readonly", width=15)
        self.days_combo.grid(row=1, column=1, pady=2, padx=(5, 0))
        
        # 按钮区域
        button_frame = ttk.Frame(self.control_frame)
        button_frame.grid(row=2, column=0, columnspan=2, pady=10, sticky="ew")
        
        self.fetch_btn = ttk.Button(button_frame, text="获取数据", command=self.fetch_data)
        self.fetch_btn.pack(side="left", padx=(0, 5))
        
        self.analyze_btn = ttk.Button(button_frame, text="技术分析", command=self.analyze_data, state="disabled")
        self.analyze_btn.pack(side="left", padx=5)
        
        self.predict_btn = ttk.Button(button_frame, text="AI预测", command=self.predict_trend, state="disabled")
        self.predict_btn.pack(side="left", padx=5)
        
        # API配置区域
        api_frame = ttk.LabelFrame(self.control_frame, text="API配置", padding="5")
        api_frame.grid(row=3, column=0, columnspan=2, pady=10, sticky="ew")
        
        ttk.Label(api_frame, text="DeepSeek API Key:").pack(anchor="w")
        self.api_key_var = tk.StringVar()
        self.api_key_entry = ttk.Entry(api_frame, textvariable=self.api_key_var, show="*", width=30)
        self.api_key_entry.pack(fill="x", pady=2)
        
        ttk.Button(api_frame, text="保存配置", command=self.save_api_config).pack(pady=2)
        
        # 市场数据显示区域
        market_frame = ttk.LabelFrame(self.control_frame, text="市场数据", padding="5")
        market_frame.grid(row=4, column=0, columnspan=2, pady=10, sticky="ew")
        
        self.market_text = scrolledtext.ScrolledText(market_frame, height=8, width=35)
        self.market_text.pack(fill="both", expand=True)
        
        # 右侧主要显示区域
        self.display_frame = ttk.Frame(self.main_frame)
        
        # 创建Notebook用于标签页
        self.notebook = ttk.Notebook(self.display_frame)
        
        # 图表标签页
        self.chart_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.chart_frame, text="技术图表")
        
        # 预测结果标签页
        self.prediction_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.prediction_frame, text="AI预测")
        
        # 数据表格标签页
        self.data_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.data_frame, text="原始数据")
        
        # 状态栏
        self.status_frame = ttk.Frame(self.main_frame)
        self.status_var = tk.StringVar(value="就绪")
        self.status_label = ttk.Label(self.status_frame, textvariable=self.status_var)
        
        # 进度条
        self.progress = ttk.Progressbar(self.status_frame, mode='indeterminate')
        
        # 初始化各标签页内容
        self.init_chart_page()
        self.init_prediction_page()
        self.init_data_page()
    
    def setup_layout(self):
        """设置布局"""
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # 左侧控制面板
        self.control_frame.pack(side="left", fill="y", padx=(0, 10))
        
        # 右侧显示区域
        self.display_frame.pack(side="right", fill="both", expand=True)
        self.notebook.pack(fill="both", expand=True)
        
        # 状态栏
        self.status_frame.pack(side="bottom", fill="x", pady=(10, 0))
        self.status_label.pack(side="left")
        self.progress.pack(side="right", padx=(10, 0))
    
    def init_chart_page(self):
        """初始化图表页面"""
        # 图表选择区域
        chart_control = ttk.Frame(self.chart_frame)
        chart_control.pack(fill="x", padx=5, pady=5)
        
        ttk.Label(chart_control, text="图表类型:").pack(side="left")
        self.chart_type_var = tk.StringVar(value="综合分析")
        chart_types = ["价格+MA", "布林带", "RSI", "MACD", "综合分析"]
        self.chart_type_combo = ttk.Combobox(chart_control, textvariable=self.chart_type_var,
                                           values=chart_types, state="readonly")
        self.chart_type_combo.pack(side="left", padx=5)
        
        ttk.Button(chart_control, text="更新图表", command=self.update_chart).pack(side="left", padx=5)
        ttk.Button(chart_control, text="保存图表", command=self.save_chart).pack(side="left", padx=5)
        
        # 图表显示区域
        self.chart_canvas_frame = ttk.Frame(self.chart_frame)
        self.chart_canvas_frame.pack(fill="both", expand=True, padx=5, pady=5)
    
    def init_prediction_page(self):
        """初始化预测页面"""
        # 预测控制区域
        pred_control = ttk.Frame(self.prediction_frame)
        pred_control.pack(fill="x", padx=5, pady=5)
        
        ttk.Label(pred_control, text="预测天数:").pack(side="left")
        self.pred_days_var = tk.StringVar(value="7")
        pred_days_combo = ttk.Combobox(pred_control, textvariable=self.pred_days_var,
                                      values=["3", "7", "14", "30"], state="readonly", width=10)
        pred_days_combo.pack(side="left", padx=5)
        
        ttk.Button(pred_control, text="批量预测", command=self.batch_predict).pack(side="left", padx=5)
        ttk.Button(pred_control, text="导出报告", command=self.export_report).pack(side="left", padx=5)
        
        # 预测结果显示区域
        self.prediction_text = scrolledtext.ScrolledText(self.prediction_frame, height=25)
        self.prediction_text.pack(fill="both", expand=True, padx=5, pady=5)
    
    def init_data_page(self):
        """初始化数据页面"""
        # 数据控制区域
        data_control = ttk.Frame(self.data_frame)
        data_control.pack(fill="x", padx=5, pady=5)
        
        ttk.Button(data_control, text="导出CSV", command=self.export_data).pack(side="left", padx=5)
        ttk.Button(data_control, text="刷新数据", command=self.refresh_data_table).pack(side="left", padx=5)
        
        # 数据表格
        self.data_tree = ttk.Treeview(self.data_frame)
        self.data_scrollbar = ttk.Scrollbar(self.data_frame, orient="vertical", command=self.data_tree.yview)
        self.data_tree.configure(yscrollcommand=self.data_scrollbar.set)
        
        self.data_tree.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        self.data_scrollbar.pack(side="right", fill="y", pady=5)
    
    def fetch_data(self):
        """获取数据"""
        if self.is_loading:
            return
        
        symbol = self.symbol_var.get()
        days = int(self.days_var.get())
        
        def fetch_thread():
            try:
                self.is_loading = True
                self.root.after(0, lambda: self.set_status("正在获取数据...", True))
                self.root.after(0, lambda: self.set_buttons_state(False))
                
                # 获取价格数据
                price_data = self.data_fetcher.get_price_data(symbol, days)
                
                # 获取市场数据
                market_data = self.data_fetcher.get_market_data(symbol)
                
                # 更新界面
                self.root.after(0, lambda: self.update_market_display(market_data))
                self.root.after(0, lambda: self.set_status(f"成功获取 {symbol} {days}天数据", False))
                
                # 存储数据
                self.current_data[symbol] = price_data
                
                # 启用分析按钮
                self.root.after(0, lambda: self.set_buttons_state(True, analyze=True))
                
            except Exception as e:
                error_msg = f"获取数据失败: {str(e)}"
                logger.error(error_msg)
                self.root.after(0, lambda: self.set_status(error_msg, False))
                self.root.after(0, lambda: messagebox.showerror("错误", error_msg))
            finally:
                self.is_loading = False
        
        thread = threading.Thread(target=fetch_thread)
        thread.daemon = True
        thread.start()
    
    def analyze_data(self):
        """分析数据"""
        if self.is_loading:
            return
        
        symbol = self.symbol_var.get()
        if symbol not in self.current_data:
            messagebox.showwarning("警告", "请先获取数据")
            return
        
        def analyze_thread():
            try:
                self.is_loading = True
                self.root.after(0, lambda: self.set_status("正在进行技术分析...", True))
                
                # 计算技术指标
                analyzed_data = self.indicator_analyzer.analyze_price_data(self.current_data[symbol])
                
                # 生成交易信号
                signals_data = self.indicator_analyzer.get_trading_signals(analyzed_data)
                
                # 更新数据
                self.current_data[symbol] = signals_data
                
                # 更新数据表格
                self.root.after(0, self.refresh_data_table)
                
                # 更新图表
                self.root.after(0, self.update_chart)
                
                self.root.after(0, lambda: self.set_status("技术分析完成", False))
                self.root.after(0, lambda: self.set_buttons_state(True, predict=True))
                
            except Exception as e:
                error_msg = f"技术分析失败: {str(e)}"
                logger.error(error_msg)
                self.root.after(0, lambda: self.set_status(error_msg, False))
                self.root.after(0, lambda: messagebox.showerror("错误", error_msg))
            finally:
                self.is_loading = False
        
        thread = threading.Thread(target=analyze_thread)
        thread.daemon = True
        thread.start()
    
    def predict_trend(self):
        """AI趋势预测"""
        if self.is_loading:
            return
        
        symbol = self.symbol_var.get()
        if symbol not in self.current_data:
            messagebox.showwarning("警告", "请先获取并分析数据")
            return
        
        # 检查API配置
        if not self.init_ai_predictor():
            return
        
        def predict_thread():
            try:
                self.is_loading = True
                self.root.after(0, lambda: self.set_status("正在进行AI预测...", True))
                
                prediction_days = int(self.pred_days_var.get())
                prediction = self.ai_predictor.predict_trend(
                    self.current_data[symbol], symbol, prediction_days
                )
                
                # 存储预测结果
                self.predictions[symbol] = prediction
                
                # 更新预测显示
                self.root.after(0, lambda: self.update_prediction_display(prediction))
                
                self.root.after(0, lambda: self.set_status("AI预测完成", False))
                
            except Exception as e:
                error_msg = f"AI预测失败: {str(e)}"
                logger.error(error_msg)
                self.root.after(0, lambda: self.set_status(error_msg, False))
                self.root.after(0, lambda: messagebox.showerror("错误", error_msg))
            finally:
                self.is_loading = False
        
        thread = threading.Thread(target=predict_thread)
        thread.daemon = True
        thread.start()
    
    def batch_predict(self):
        """批量预测多个币种"""
        if self.is_loading:
            return
        
        if not self.init_ai_predictor():
            return
        
        # 选择要预测的币种
        coins = ["BTC", "ETH", "SOL", "XRP"]  # 可以扩展
        
        def batch_predict_thread():
            try:
                self.is_loading = True
                self.root.after(0, lambda: self.set_status("正在批量预测...", True))
                
                prediction_days = int(self.pred_days_var.get())
                batch_data = {}
                
                # 获取所有币种数据
                for coin in coins:
                    try:
                        price_data = self.data_fetcher.get_price_data(coin, 30)
                        analyzed_data = self.indicator_analyzer.analyze_price_data(price_data)
                        batch_data[coin] = analyzed_data
                        self.root.after(0, lambda c=coin: self.set_status(f"已获取 {c} 数据", True))
                    except Exception as e:
                        logger.warning(f"获取 {coin} 数据失败: {e}")
                
                # 批量预测
                if batch_data:
                    batch_predictions = self.ai_predictor.analyze_multiple_coins(batch_data, prediction_days)
                    
                    # 生成报告
                    report = self.ai_predictor.generate_market_report(batch_predictions)
                    
                    # 更新显示
                    self.root.after(0, lambda: self.prediction_text.delete(1.0, tk.END))
                    self.root.after(0, lambda: self.prediction_text.insert(tk.END, report))
                    
                    # 存储结果
                    self.predictions.update(batch_predictions)
                
                self.root.after(0, lambda: self.set_status("批量预测完成", False))
                
            except Exception as e:
                error_msg = f"批量预测失败: {str(e)}"
                logger.error(error_msg)
                self.root.after(0, lambda: self.set_status(error_msg, False))
                self.root.after(0, lambda: messagebox.showerror("错误", error_msg))
            finally:
                self.is_loading = False
        
        thread = threading.Thread(target=batch_predict_thread)
        thread.daemon = True
        thread.start()
    
    def update_chart(self):
        """更新图表"""
        symbol = self.symbol_var.get()
        if symbol not in self.current_data:
            return
        
        try:
            # 清除旧图表
            for widget in self.chart_canvas_frame.winfo_children():
                widget.destroy()
            
            chart_type = self.chart_type_var.get()
            df = self.current_data[symbol]
            
            # 根据选择的图表类型生成图表
            if chart_type == "价格+MA":
                fig = self.chart_plotter.plot_price_with_ma(df, symbol)
            elif chart_type == "布林带":
                fig = self.chart_plotter.plot_bollinger_bands(df, symbol)
            elif chart_type == "RSI":
                fig = self.chart_plotter.plot_rsi(df, symbol)
            elif chart_type == "MACD":
                fig = self.chart_plotter.plot_macd(df, symbol)
            else:  # 综合分析
                fig = self.chart_plotter.plot_comprehensive_chart(df, symbol)
            
            # 嵌入图表到Tkinter
            canvas = FigureCanvasTkAgg(fig, self.chart_canvas_frame)
            canvas.draw()
            canvas.get_tk_widget().pack(fill="both", expand=True)
            
            # 保存当前图表引用
            self.current_figure = fig
            
        except Exception as e:
            logger.error(f"更新图表失败: {e}")
            messagebox.showerror("错误", f"更新图表失败: {str(e)}")
    
    def update_market_display(self, market_data):
        """更新市场数据显示"""
        self.market_text.delete(1.0, tk.END)
        
        display_text = f"""币种: {market_data.get('name', 'N/A')} ({market_data.get('symbol', 'N/A')})
当前价格: ${market_data.get('current_price', 0):.4f}
市值: ${market_data.get('market_cap', 0):,.0f}
24小时交易量: ${market_data.get('total_volume', 0):,.0f}
24小时涨跌: {market_data.get('price_change_percentage_24h', 0):.2f}%
7日涨跌: {market_data.get('price_change_percentage_7d', 0):.2f}%
30日涨跌: {market_data.get('price_change_percentage_30d', 0):.2f}%
市值排名: #{market_data.get('market_cap_rank', 'N/A')}
流通供应量: {market_data.get('circulating_supply', 0):,.0f}
历史最高: ${market_data.get('ath', 0):.4f}
历史最低: ${market_data.get('atl', 0):.4f}"""
        
        self.market_text.insert(tk.END, display_text)
    
    def update_prediction_display(self, prediction):
        """更新预测结果显示"""
        self.prediction_text.delete(1.0, tk.END)
        
        display_text = f"""AI趋势预测结果
=====================

币种: {prediction.get('symbol', 'N/A')}
预测时间: {prediction.get('prediction_date', 'N/A')}
预测天数: {prediction.get('prediction_days', 'N/A')}天

趋势方向: {prediction.get('trend_direction', 'N/A')}
信心度: {prediction.get('confidence', 'N/A')}
风险等级: {prediction.get('risk_level', 'N/A')}
交易建议: {prediction.get('trading_suggestion', 'N/A')}

价格预测:
当前价格: ${prediction.get('current_price', 0):.4f}
目标价格: ${prediction.get('target_price', 0):.4f}
支撑位: ${prediction.get('support_level', 0):.4f}
阻力位: ${prediction.get('resistance_level', 0):.4f}

分析摘要:
{prediction.get('analysis_summary', 'N/A')}

关键因素:"""
        
        key_factors = prediction.get('key_factors', [])
        for i, factor in enumerate(key_factors, 1):
            display_text += f"\n{i}. {factor}"
        
        display_text += "\n\n免责声明: 本预测仅供参考，不构成投资建议。"
        
        self.prediction_text.insert(tk.END, display_text)
    
    def refresh_data_table(self):
        """刷新数据表格"""
        symbol = self.symbol_var.get()
        if symbol not in self.current_data:
            return
        
        try:
            # 清除旧数据
            for item in self.data_tree.get_children():
                self.data_tree.delete(item)
            
            df = self.current_data[symbol]
            
            # 设置列
            columns = ['时间', '价格', '成交量'] + [col for col in df.columns 
                      if col not in ['price', 'volume', 'symbol'] and not col.startswith('BB_')]
            
            self.data_tree["columns"] = columns
            self.data_tree["show"] = "headings"
            
            # 设置列标题
            for col in columns:
                self.data_tree.heading(col, text=col)
                self.data_tree.column(col, width=100)
            
            # 添加数据（最近20条）
            recent_data = df.tail(20)
            for idx, row in recent_data.iterrows():
                values = [idx.strftime('%Y-%m-%d %H:%M'), f"{row['price']:.4f}", f"{row.get('volume', 0):.0f}"]
                
                for col in columns[3:]:  # 跳过时间、价格、成交量
                    if col in row and pd.notna(row[col]):
                        values.append(f"{row[col]:.4f}")
                    else:
                        values.append("N/A")
                
                self.data_tree.insert("", "end", values=values)
                
        except Exception as e:
            logger.error(f"刷新数据表格失败: {e}")
    
    def init_ai_predictor(self):
        """初始化AI预测器"""
        api_key = self.api_key_var.get().strip()
        if not api_key:
            # 尝试从环境变量获取
            api_key = os.getenv('DEEPSEEK_API_KEY')
            if api_key:
                self.api_key_var.set(api_key)
        
        if not api_key:
            messagebox.showwarning("警告", "请先配置DeepSeek API密钥")
            return False
        
        try:
            if not self.ai_predictor:
                self.ai_predictor = AIPredictor(api_key=api_key)
            return True
        except Exception as e:
            messagebox.showerror("错误", f"初始化AI预测器失败: {str(e)}")
            return False
    
    def save_api_config(self):
        """保存API配置"""
        api_key = self.api_key_var.get().strip()
        if not api_key:
            messagebox.showwarning("警告", "请输入API密钥")
            return
        
        try:
            # 保存到.env文件
            env_content = f"DEEPSEEK_API_KEY={api_key}\nDEEPSEEK_BASE_URL=https://api.deepseek.com/v1\n"
            with open('.env', 'w') as f:
                f.write(env_content)
            
            messagebox.showinfo("成功", "API配置已保存")
            
            # 重新初始化AI预测器
            self.ai_predictor = None
            
        except Exception as e:
            messagebox.showerror("错误", f"保存配置失败: {str(e)}")
    
    def save_chart(self):
        """保存图表"""
        if hasattr(self, 'current_figure'):
            filename = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("PDF files", "*.pdf"), ("All files", "*.*")]
            )
            if filename:
                try:
                    self.current_figure.savefig(filename, dpi=300, bbox_inches='tight')
                    messagebox.showinfo("成功", f"图表已保存到: {filename}")
                except Exception as e:
                    messagebox.showerror("错误", f"保存图表失败: {str(e)}")
        else:
            messagebox.showwarning("警告", "没有可保存的图表")
    
    def export_data(self):
        """导出数据"""
        symbol = self.symbol_var.get()
        if symbol not in self.current_data:
            messagebox.showwarning("警告", "没有可导出的数据")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        if filename:
            try:
                df = self.current_data[symbol]
                if filename.endswith('.xlsx'):
                    df.to_excel(filename)
                else:
                    df.to_csv(filename)
                messagebox.showinfo("成功", f"数据已导出到: {filename}")
            except Exception as e:
                messagebox.showerror("错误", f"导出数据失败: {str(e)}")
    
    def export_report(self):
        """导出预测报告"""
        if not self.predictions:
            messagebox.showwarning("警告", "没有可导出的预测报告")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("JSON files", "*.json"), ("All files", "*.*")]
        )
        if filename:
            try:
                if filename.endswith('.json'):
                    with open(filename, 'w', encoding='utf-8') as f:
                        json.dump(self.predictions, f, ensure_ascii=False, indent=2)
                else:
                    report = self.ai_predictor.generate_market_report(self.predictions) if self.ai_predictor else str(self.predictions)
                    with open(filename, 'w', encoding='utf-8') as f:
                        f.write(report)
                messagebox.showinfo("成功", f"报告已导出到: {filename}")
            except Exception as e:
                messagebox.showerror("错误", f"导出报告失败: {str(e)}")
    
    def set_status(self, message, loading=False):
        """设置状态"""
        self.status_var.set(message)
        if loading:
            self.progress.start()
        else:
            self.progress.stop()
    
    def set_buttons_state(self, enabled, analyze=False, predict=False):
        """设置按钮状态"""
        state = "normal" if enabled else "disabled"
        self.fetch_btn.config(state=state)
        
        if analyze:
            self.analyze_btn.config(state=state)
        if predict:
            self.predict_btn.config(state=state)


def main():
    """主函数"""
    root = tk.Tk()
    app = CryptoAnalyzerGUI(root)
    
    # 设置窗口图标和其他属性
    try:
        root.state('zoomed')  # Linux下最大化
    except:
        pass  # Windows/Mac下可能不支持
    
    root.mainloop()


if __name__ == "__main__":
    main()
